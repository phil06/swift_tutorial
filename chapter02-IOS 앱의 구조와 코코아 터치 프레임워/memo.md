# 앱의 기본 구조

## 엔트리 포인트와 앱의 초기화 과정

* Objective-C
C언어에 기반하고 있어서 이를 이용해 만들어진 IOS앱도 main() 함수부터 시작된다.
xcode 프로젝트를 생성하면 main() 함수가 자동으로 만들어진다.

```swift
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}

```

실행시 시스템으로부터 전달받은 두개의 인자(argc, argv)값과 AppDelegate 클래스를 이용해 UIApplicationMain() 함수를 호출한다.
생성된 UIApplication 객체는 UIKit 프레임워크에 속해있어 이후의 앱 제어는 UIKit 프레임워크로 이관된다.
    * UIApplication
    앱의 본체라고 할 수 있다.(사실상 앱 그자체를 의미. 모든것들이 다 UIApplication에 포함되어있는 하위 객체다)
    AppDelegate라는 대리객체를 앞에두고 커스텀 코드를 처리할 수 있도록 권한을 부여한다.
    * AppDelegate
    IOS 애플리케이션 내에서 오직 하나의 인스턴스만 생성되도록 시스템적으로 보장받는다.
* Swift
C기반의 언어가 아니다. (엔트리 포인트가 존재하지 않는다)
C에서의 UIApplication 객체를 생성하는 일련의 과정을 `@UIApplicationMain` 이라는 어노테이션 표기로 대체한다.
[**IOS 앱 생명주기**]
![15620B3D4EDC536A0F.png](/images/chapter02_01.png)

이벤트 루프에서는 특정 이벤트가 발생했을때 우리가 만든 핸들(like @IBAction)을 통해 커스텀 코드를 실행할 수 있도록 처리한다.

## MVC 패턴

## 앱의 상태 변화

**[앱의 라이프 사이클]**

| step | status | description |
| ---- | ------ | ----------- |
| Not Running |  | 앱이 시작되지 않았거나 실행되었지만 시스템에 의해 종료된 상태 |
| Inactive | Foreground | 실행중이지만 아무런 이벤트를 받지 않고 있는 상태 |
| Active | Foreground | 실행중이며, 이벤트를 받고 있는 상태를 나타낸다 |
| Background | Background | 백그라운드에 있지만 여전히 코드가 실행되고 있는 상태 |
| Suspended |  | 앱이 메모리에 유지되지만 실행되는 코드가 없는 상태. 메모리가 부족한 상황이 오면 IOS 시스템은 포그라운드에 있는 앱의 여유 메모리 공간을 확보하기 위해 Suspended 상태에 있는 앱들을 특별한 알림없이 정리한다. |

* `application(_:willFinishLaunchingWithOptions:)`
앱의 구동되어 필요한 초기 실행과정이 완료되기 직전에 호출
* `application(_:didFinishLaunchingWithOptions:)`
사용자에게 화면으로 표시되기 직전에 호출되는 메소드
* `applicationDidBecomeActive(_:)`
실행된 앱이 포그라운드, 즉 화면 전면에 표시될 때 호출되는 메소드
* `applicationDidEnterBackground(_:)`
백그라운드 상태에 진입했을때 호출
* `applicationWillTerminate(_:)`
종료되기 직전에 호출

# IOS와 코코아 터치 프레임워크

클래스 이름 앞에 공통적으로 붙는 접두어는 대부분 소속을 나타냄.(UI**** 가 붙는 형식의 클래스는 UIKit 프레임워크에 속해있다는것을 의미함. 즉슨 스위프트 언어에서 제공하는 것이 아님. 그래서 프레임워크를 import 해줘야함)
파운데이션 프레임워크, UIKit프레임워크, 웹킷 프레임워크 등의 계층을 거슬러 올라가면 코코아 터치 라는 거대한 프레임워크가 있음.

## IOS

코코아 터치 프레임워크가 하드웨어와 앱 사이를 중계해주는 인터페이스 역할을 한다.

## 코코아 터치 프레임워크

**[주요 프레임워크]**

| 프레임워크 명칭 | 설명 |
| -------- | --- |
| Foundation Framwork | 핵심 객체와 네트워크, 문자열 처리 등의 서비스 제공 |
| UIKit Framwork | 유저 인터페이스를 제공 |
| GameKit Framwork | 게임센터를 연동하거나 근거리 P2P 연결을 제공 |
| iAd Framwork | 배너 형태 또는 팝업 형태의 광고를 삽입할 수 있도록 해 주는 광고 관련 프레임워크 |
| MapKit Framwork | 위치 정보나 지도 관련 서비스를 이용할 수 있도록 해주는 프레임워크 |
| Address Book UI Framwork | 번들 애플리케이션으로 제공되는 주소록 앱의 인터페이스와 기능을 커스텀 앱 내에서도 그대로 사용할 수 있도록 해주는 프레임워크 |
| EventKit UI Framwork | 이벤트 처리에 필요한 유저 인터페이스 제공 |
| Message UI Framwork | 메시지 앱의 인터페이스와 기능을 커스텀 앱 내에서도 그대로 사용할 수 있도록 제공 |
| UserNotifications Framwork | 알림 처리 |
| WebKit Framwork | 웹 관련 기능 구현 제공 |

앱의 특징적인 부분은 UIKit 프레임워크, 내부적으로 돌아가는 기능은 Foundation 프레임워크가 처리.
어플리케이션 킷 프레임워크는 데스크톱용 유저 인터페이스 담당으로 줄여서 AppKit 프레임워크라고 부른다.

* 코코아터치 F & 코코아 F
코코아 터치 프레임워크는 코코아 프레임워크를 바탕으로 만들어졌다.
두 프레임워크가 사용하는 Foundation Framework는 동일하지만 유저 인터페이스는 다르다.
코코아 프레임워크에서 사용되는 앱킷 프레임워크는 코코아 터치 프레임워크에서 UIKit 프레임워크로 대체되었다.
* 프레임워크의 계층관계
상위계층 : 사용자에 가깝고 구체적으로 구현되어있어 손쉽게 사용가능한 형태 (구체화 되어있음)
하위계층 : 추상적이면서 하드웨어 쪽에 가까워 다루기에 번거로움. 범용이고 원천적이라 다양하게 확장 가능.
프레임워크 계층은 하드웨어와 어플리케이션 사이를 중계하는 위치에 자리잡고 있다.

**[프레임워크 계층 구조]**

| 프레임워크 | 설명 |
| ----- | --- |
| Core OS | IOS가 운영체제로서 기능하기위한 핵심 영역 |
| Core Service | 대표적으로 Foundation Framework, CoreFoundation Framework |
| Media | 코어 서비스 계층에 의존적. 그래픽 과나련 서비스나 멀티미디어 관련 서비스 제공 |
| Cocoa Touch | UIKit Framework 가 속해있음. |

# 앱을 구성하는 핵심 객체들

## IOS 유저 인터페이스의 표현 구조

* 윈도우
항상 유저 인터페이스 표현 계층의 최상위에 위치함
뷰의 일종이지만 직접 컨텐츠를 가지지 않고 컨텐츠를 가진 뷰를 배치해서 출력하는 역할.
화면이 전환되어도 윈도우 객체는 전환되지 않을뿐 내부 뷰의 컨텐츠가 변경되는것.
항상 루트 뷰 컨트롤러만 참조함.
* 뷰
컨텐츠를 담아 스크린에 표시하고 사용자의 입력에 반응함
* 컨텐츠 뷰 컨트롤러
하나의 화면을 담당하는 뷰를 씬(Scene)이라고도 한다.
씬을 담당하고 콘텐츠를 표시하는 뷰 컨트롤러.
* 컨테이너 뷰 컨트롤러
씬을 표현하는 역할 대신 다른 뷰 컨트롤러의 연결관계를 관리.
내비게이션 컨트롤러나 탭 바 컨트롤러, 페이지 컨트롤러 등이 대표적임.
* 뷰의 계층 구조(View hierachy)
컨테이너 역할을 하는 뷰
다른 뷰를 포함하는 뷰는 슈퍼뷰 / 슈퍼뷰에 포함된 뷰는 서브 뷰
계층구조의 상위에는 뷰가 하나만 존재함. (= 루트뷰 / 컨텐츠뷰)

## 뷰 컨트롤러

* View Controller
가장 기본이 되는 컨트롤러
* Navigation Controller
앱의 화면 이동에 대한 관리와 그에 연관된 처리를 담당해주는 컨트롤러.
뷰를 포함하고 있지 않음. (다른 컨트롤러와 결합하여 부분적으로 화면을 구성함)
* Table View Controller
여러 항목이나 데이터를 화면에 나열하기 위한 목적으로 사용되는 컨트롤러
* Tab Bar Controller
화면을 나타내는 여러 개의 탭이 있고, 탭을 터치하면 화면이 전환되는 형태의 앱을 만들때 사용
* Split View Controller
목록을 나열하는 마스터 페이지와 그 목록 각각에 대한 세부 내용을 보여주는 디테일 페이지로 구성
직접적으로 화면을 구성하지 않음.
마스터/디테일 페이지로 사용할 뷰 컨트롤러들을 화면의 크기에 따라 적절히 조합해주는 역할만 함.

## 뷰 컨트롤러의 상태 변화와 생명 주기

새로운 장면으로 전환하거나 이전 화면으로 복귀하는 과정에서 뷰 컨트롤러 객체 생성과 소멸이 발생함.
뷰 컨트롤러가 특정 상태 변화를 일으킬때 호출하는 메소드가 정의되어 있음.

**[뷰 컨트롤러 상태변화]**
![1_etDLgjBamDJoiaM3_hie9A.png](/images/chapter02_02.png)

| status | description |
| ------ | ----------- |
| Appearing | 스크린에 등장하기 시작한 순간부터 등장을 완료하기 직전까지의 상태 |
| **`viewWillAppear(_:)`** | 처음 실행되거나 다시 등장하기 시작하는 상태로 바뀌는 동안 호출 |
| Appeared | 스크린 전체에 완전히 등장한 상태 |
| **`viewDidAppear(_:)`** | 완전히 등장하고 나서 호출 |
| Disappearing | 스크린에서 가려지기 시작해서 완전히 가려지기 직전까지의 상태 |
| **`viewWillDisappear(_:)`** | 스크린에서 화면이 퇴장하는 상태변화 발생시 호출 |
| Disappeared | 스크린에서 완전히 가려졌거나 혹은 퇴장한 상태 |
| **`viewDidDisappear(_:)`** | 화면이 퇴장하는 변화가 완료되었을때 호출 |
