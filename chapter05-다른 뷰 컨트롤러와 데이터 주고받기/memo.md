# 화면 전환 과정에서의 값 전달방식

개념1. 뷰 컨트롤러에서 다음 뷰 컨트롤러로 값을 직접 전달
개념2. 공통저장소를 만들어 뷰 컨트롤러에서 여기에 값을 저장하고 화면을 이동하면 다음 뷰 컨트롤러에서 이 저장소를 열어 다시 값을 꺼내오는 공유방식

* **직접 전달방식(동기방식)**
영속적으로 값을 저장할 필요가 없는 화면 전환에서 사용
값을 저장하는 방식보다 상대적으로 소스코드가 간결해짐
전달받는 쪽의 뷰 컨트롤러가 받을 값의 명세를 모두 파악하고 대입할 변수를 미리 생성해 두어야 함(이를 위해 보내는 뷰 컨트롤러에서 받는 뷰 컨트롤러에 대한 정보를 미리 알아야 함)
* **간접 전달 방식(비동기 방식)**
지속적으로 값을 저장할 필요가 있는 화면 전환에서 사용
값을 계속 사용할 수 있게 저장해 놓는 데에는 좋지만, 저장소에 데이터가 저장되는 시점과 화면 전환 시점이 일치하지 않으면 전달이 제대로 안될 수 있음
값을 직접 전달하는 방식보다 상대적으로 소스코드가 복잡해짐
보내는쪽/받는쪽 모두 저장소의 위치를 사전에 공유하고 있어야 함

# 뷰 컨트롤러에 직접 값을 전달하기

* 텍스트 필드의 속성 목록 중간에 위치한 `Keyboard Type`항목으로 키보드 타입 지정 가능
* 액션 메소드를 정의할때 선택하는 매개변수 타입
Any타입으로 입력된 sender 매개변수에서 필요한 속성을 참조하려면 그에 맞는 객체 타입으로 캐스팅이 필요함(대체로 다운캐스팅=Down Casting)
업캐스팅(Up Casting)은 오류가 발생할 일이 거의 없다
    * 개별 타입을 선택해야 할때(UI****)
    액션 메소드를 호출한 컨트롤러의 속성값이 필요하거나, 이를 제어해야 할때
    * 범용 타입을 선택해야 할때(Any)
    서로 다른 타입의 컨트롤이 동일한 액션 메소드를 호출하게끔 처리하고 싶을 때
    액션 메소드를 호출한 컨트롤의 정보가 필요 없을 때

| 캐스팅 타입 | 결과값 | 예시 |
| ------ | --- | --- |
| 옵셔널 캐스팅 | 옵셔널 타입 | sender as? UISwitch |
| 강제 캐스팅 | 일반 타입 | sender as! UISwitch |

아울렛 변수는 외부에서 값을 직접 대입할 수 없는 변수로 시스템에 의해 값이 주입된다.(외부 객체에서 직접 참조할 수 없도록 제한되어 있음)

``` swift
//뷰 컨트롤러 인스턴스 생성 & 다운캐스팅
guard let rvc = self.storyboard?.instantiateViewController(withIdentifier: "RVC") as? ResultViewController else {
    return
}

```

instantiateViewController메소드를 호출하여 생성된 인스턴스는 기본적으로 UIViewController 타입이다.

## 프레젠테이션 방식으로 화면 전환하면서 값을 전달하기

## 내비게이션 컨트롤러를 통해 화면 전환하면서 값을 전달하기

## 세그웨이를 이용하여 화면 전환하면서 값을 전달하기

* 메뉴얼 세그웨이
* 액션 세그웨이

어느 세그웨이를 택하는 값을 전달하는 방식은 동일하다
구분없이 모든 세그웨이가 실행되기 전에 IOS는 `prepare(for:sender:)` 메소드를 먼저 호출한다.
첫번째 인자인 segue 매개변수를 통해 세그웨이가 생성한 뷰 컨트롤러 인스턴스 참조를 읽어올 수 있다.
세그웨이는 항상 출발지/목적지 로 연결된 뷰 컨트롤러 인스턴스가 존재한다.

``` swift
//목적지 뷰 컨트롤러 인스턴스 읽어옴
let dest = segue.destination

```

# 이전 화면으로 값을 전달하기

첫화면->두번째화면 으로 값을 전달 할 때는 첫화면의 인스턴스가 초기화되지 않기 때문에 viewDidLoad() 메소드가 호출되지 않는다.(대신 화면이 새롭게 그려질 때마다 호출되는 `viewWillAppear(_:)` 메소드가 호출된다)

반대 방향으로 값을 전달하고자 하는 경우 값의 성격을 고려해 소실되어도 상관없다면 동기방식, 소실되어서는 안되는 값이라면 비동기 방식으로 처리해야 한다.

## 직접 값을 주고 받기

값은 휘발성임.

## 저장소를 사용하여 값을 주고 받기

비동기 방식임.
저장소 역할을 담당할 객체 = AppDelegate 클래스(대표적인 예)

* AppDelegate
UIApplication 객체로부터 생명주기 관리를 위임받아 커스텀 코드를 처리하는 역할
객체에 값을 저장하면 앱이 종료되지 않는 한 유지 가능
싱글톤(앱 전체를 통틀어 하나의 인스턴스만 존재하도록 IOS 시스템에 의해 보장됨)
직접 생성할 수 없으며 `UIApplication.shared.delegate` 구문을 통해 현재 생성되어있는걸 참조하는 방식(UIApplicationDelegate 타입이기에 다운캐스팅 해야함)
* UserDefaults(구 NSUserDefaults)
값을 반 영구정으로 저장 가능.
간단한 데이터에 사용됨
앱을 삭제하기 전까지는 반영구적으로 데이터가 유지됨
NSData, NSString, NSNumber, NSDate, NSArray, NSDictionary 타입 외에도 스위프트에서 제공하는 기본 자료형까지 저장가능함

``` swift
let ud = UserDefaults.standard
//값 저장
ud.set(self.email.text, forKey: "email")
//값 조회
ud.string(forKey: "email")

```

값 조회시 string 만 옵셔널임

``` swift
//범용 데이터 타입을 반환하는 메소드
ud.value(forKey: "email") as? string
ud.object(forKey: "email") as? string

```

* Core Data
소규모 데이터베이스처럼 다소 복잡한 형태의 데이터에 사용됨

[커스텀 AppDelegate 생성 원칙]

1. UIResponse 클래스를 상속받는다
2. UIApplicationDelegate 프로토콜 구현을 선언
3. @UIApplicationMain 어노테이션을 붙여야 함