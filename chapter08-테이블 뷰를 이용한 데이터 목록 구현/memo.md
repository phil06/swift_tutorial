선택도(Cardinality) : 데이터베이스의 설계 원리

특정 카테고리를 선택하여 나온 결과값의 개수가 적을수록 `선택도가 높다`고 표현하며 콘텐츠 분류가 잘 되었다고 할 수 있다.

# 테이블 뷰 컨트롤러
뷰 컨트롤러를 바탕으로 만들어진 특수한 컨트롤러. 뷰가 루트 뷰로 정의되어 있다. 목록 형식의 데이터를 화면에 표현할 때 사용.

[chapter 08_1] 

* 하나의 화면을 의미하는 씬(Scene)은 보통 하나의 뷰 컨트롤러로 구성되는데 위 구조에서는 테이블 뷰 컨트롤러가 씬을 담당한다.
* 테이블 뷰가 최상위 루트 뷰 이다.
* 여러개의 행을 테이블 뷰 셀 이라고 한다
* 테이블 뷰 셀은 다시 내부에 콘텐츠 뷰 를 가진다.

섹션은 하나의 테이블 뷰 내에서 셀들을 그룹으로 묶을 수 있는 단위.

테이블 뷰 컨트롤러는 UIKit 프레임워크에 UITableViewController 클래스로 구현되어 있음.



* 프로토 타입 셀의 일반 영역 
  * Cell Content : 셀에 표현될 콘텐츠

    모바일 디바이스에 따라 Accessory View 영역은 너비가 고정값을 유지하는 반면 Cell Content영역은 가변적인 너비값으로 처리된다.

    내부적으로 콘텐츠를 표현하는 Image 영역과 텍스트를 표현하는 Text 영역으로 나뉜다.

  * Accessory View : 콘텐츠의 부가 정보 여부. 셀의 오른쪽 끝에 표시될 아이콘 선택시 사용.
    * Disclosure Indicator : 테이블 뷰 셀을 선택했을 때 데이터 구조상 하위 레벨에 해당하는 또다른 테이블 뷰 화면을 보여줌
    * Detail Disclosure Button : Detail옵션과 Disclosure Indicator 옵션이 합쳐진 것. 선택했을때 그에 대한 상세 내용을 보여주게 됨을 의미. 하위 레벨의 테이블 뷰가 될수도, Detail과 같이 일반 뷰에 표현된 상세 내용이 될 수도 있다.
    * Checkmark : 테이블 뷰 아이템의 개별 행을 사용자가 선택했다는것을 나타냄(선택목록). 선택용 목록인 팝업목록과 비슷함. 하나만 선택하도록 제한하거나 여러개 선택할수있도록 허용가능.
    * Detail : 셀을 선택했을 때 이에 대한 상세 내용을 일반 뷰로 보여주게됨을 의미

  화면에 콘텐츠를 보여주기만 하는 것이 아니라 콘텐츠 자체에 대한 편집이 필요할 경우를 위해 코코아 터치 프레임워크에서 프로토타입 셀에 표준 편집 인터페이스도 제공함(Editing Control / Cell Content / Reordering Control)

## 프로토타입 셀을 이용한 테이블 뷰 실습

**TableViewCell**

기본 타이틀은 Basic의 경우 textLabel 속성, 그외의 경우 detailTextLabel 속성을 통해 접근 가능.

* Style : 테이블 뷰 셀에 출력되는 항목과 형식 결정
  * Basic : 기본 타이틀만 출력. 
  * Right Detail : 기본 타이틀 + 상세(오른쪽 끝).
  * Left Detail : 기본 타이틀 + 상세(왼쪽 끝)
  * Subtitle : 기본타이틀 + 상세(타이틀 아래)
    
프로토타입 셀은 아울렛 변수를 연결하지 않고 인스펙터 탭에서 Identifier 아이디를 입력한다. 
프로토타입 셀이 실제로 화면에 표시되는 컨트롤이 아니기 때문에. 실제로 사용할 셀을 목록의 개수만큼 생성하고, 
각각에 데이터를 바인딩 하는 과정을 거쳐 목록 화면을 구성한다. 서로 다른 형식으로 만들어진 여러 개의 프로토타입 셀을 구분하기 위해서 아이디를 부여한다.



# 데이터 소스

* 콘텐츠 표현방법
  * 정적 방법
    * 셀 각각을 프로그래밍적으로 구성하지 않고 스토리보드에서 직접 구성.
  * 동적 방법
    * 고정되지 않고 매번 갱신되는 내용을 표현하려면 테이블 뷰 셀을 프로그래밍적으로 구성해주어야 한다. 데이터소스를 테이블 뷰 각 행에 연결하는 과정을 데이터 바인딩(Data Binding)이라고 한다.

## 데이터 소스 만들기

> [Value Object 패턴] 데이터 저장을 전담하는 클래스를 별도로 분리하는 설계 방식. (=VO) 데이터 저장을 위한 클래스임을 쉽게 식별할 수 있게 하려고 클래스의 마지막에 VO라는 접미사를 붙임

```swift
    var dataset = [
    ("다크 나이트", "영웅물에 철학에 음악까지 더해져 예술이 되다", "2008-09-04", 8.95, "darknight.jpg"),
    ("호우시절", "때를 알고 내리는 좋은 비", "2009-10-08", 7.31, "rain.jpg"),
    ("말할 수 없는 비밀", "여기서 너까지 다섯 걸음", "2015-05-07", 9.19, "secret.jpg")
    ]
    
    //클로저를 이용한 프로퍼티 초기화
    lazy var list: [MovieVO] = {
        var datalist = [MovieVO]()
        for(title, desc, opendate, rating, thumbnail) in self.dataset {
            let mvo = MovieVO()
            mvo.title = title
            mvo.description = desc
            mvo.opendate = opendate
            mvo.rating = rating
            mvo.thumbnail = thumbnail
            datalist.append(mvo)
        }
        return datalist
    }()
```

* lazy keyword : 배열변수를 미리 생성해서 메모리를 낭비할 필요가 없기 때문. `lazy`키워드는 참조되는 시점에 맞추어 초기화되어 메모리 낭비를 줄인다.
lazy 키워드를 붙이지 않은 프로퍼티는 다른 프로퍼티를 참조할 수 없다. (프로퍼티들이 초기화 되는 순서는 우리가 컨트롤할 수 있는 범위를 벗어나기때문에
변수의 클로저가 실행되는 시점에 dataset 배열이 초기화되어 있다고 보장할 수 없음. 그래서 일반 저장 프로퍼티끼리는 서로 참조가 불가능) lazy 키워드가 붙어있으면
다른 일반 프로퍼티가 초기화 된 후 마지막에 초기화처리되어 초기화 시점을 통제할 수 있는것처럼 수행됨.

## 테이블 뷰와 데이터 소스 연동

데이터소스와 테이블 뷰를 연동하는 과정은 UITableViewDataSource라는 프로토콜에 의존한다. 이 프로토콜을 참고하여 지정된 메소드를 호출함으로써 데이터소스와 테이블 뷰를 연동함.

iOS시스템이 필요에 의해 호출하는 메소드로 자바스크립트의 시스템이 호출하는 콜백함수(Callback Function)개념으로 생각하면 된다.

* tableView(_:numberOfRowsInSection:)

  테이블 뷰가 생성해야 할 행(row)의 개수를 반환. 시스템이 테이블뷰를 구성하기 위해 먼저 호출하는 메소드. 
  첫번째 매개변수는 테이블 뷰 객체정보, 두번째 매개변수는 섹션 정보이다.

* tableView(_:cellForRowAt:)

  각 행이 화면에 표현해야 할 내용을 구성하는 데에 사용된다. 반환하는 값은 전체 테이블 뷰의 목록이 아니라 하나하나의 개별적인 테이블 셀 객체.
  화면에 표현해야 할 목록수만큼 메소드가 반복적으로 호출된다.
  첫번째 매개변수는 테이블 뷰 객체에 대한 참조, 두번째 매개변수는 구성할 행에 대한 참조정보.
  
* tableView(_:didSelectRowAt:)

  사용자가 목록 중에서 특정 행을 선택했을 때 호출.
  첫번째 매개변수는 사용자가 터치한 테이블 뷰에 대한 참조값, 두번째 매개변수는 터치된 행에 대한 정보
  
  ```swift
      override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        //주어진 행에 맞는 데이터 소스를 읽어온다
        let row = self.list[indexPath.row]
        
        //테이블 셀 객체를 직접 생성하는 대신 큐로부터 가져옴
        let cell = tableView.dequeueReusableCell(withIdentifier: "ListCell")!
        
        //프로토타입 셀이 제공하는 라벨 사용했을때
        cell.textLabel?.text = row.title
        cell.detailTextLabel?.text = row.description
        
        return cell
    }
  ```
  
  재사용 큐(Resusable Queue) : 한차례 사용된 테이블 셀 인스턴스가 폐기되지 않고 재사용을 위해 대기하는 공간
  
> 프로토타입 셀 하단에 뷰 객체를 추가하면 테이블 뷰 컨트롤러에서 컨텐츠를 표현하는데 필요한 공간 이외의 잔여 공간을 모두 채워줌으로써 화면에 빈 테이블 뷰 셀이 표시되는 것을 막아준다.

# 커스텀 프로토타입 셀
## 커스텀 프로토타입 셀 구현하기

커스텀 타입으로 설정된 프로토타입 셀은 textLabel이나 detailTextLabel과 같은 기본 속성을 사용하여 셀 내부의 객체를 참조할 수 없다.
스토리보드 상에서 객체에 태그값을 입력하고 소스코드에서는 이 값을 이용하여 객체를 참조해야 한다.
(객체를 식별할 수 있는 일종의 아이디나 일련번호)

[테이블 뷰 셀에 포함된 화면 요소를 소스코드에서 참조하는 방법]

  * 태그 속성값 이용 : 쉽지만 관리가 어려움
  
    `cell.viewWithTag(~~~) as? UILabel` 처럼 viewWithTag(_:) 메소드를 이용해 객체를 읽어올 수 있다. 
    메소드의 반환은 UIView이기때문에 필요에 따라 적절한 구체적 타입으로 캐스팅 해야한다.
  
  * 태그 속성값 이용 : 쉽지만 관리가 어려움
  * 아울렛 변수를 연결하여 참조 : 아울렛 변수를 이용하기 위해 프로토타입 셀을 제어할 커스텀 클래스를 직접 구현해야 함

## 커스텀 클래스로 프로토타입 셀의 객체 제어하기

프로토타입 셀 자체를 커스텀 클래스와 연결한 다음 셀 위에 올려진 객체를 아울렛 변수로 연결하여 참조.

`let cell = tableView.dequeueReusableCell(withIdentifier:"ListCell") as! MovieCell` 에서 MovieCell 클래스에 정의된 속성을 사용하기 위해 캐스팅이 이루어짐.

## 프로토타입 셀에 섬네일 이미지 추가하기

이미지 뷰와 이미지는 다른것. 이미지뷰는 이미지를 입력받고 이를 화면에 표시해주는 역할만 하는 객체, 
.image라는 속성을 가지고 있으며 UIImage 타입으로 작성된 이미지 객체를 속성에 대입받아 화면에 표현한다.

UIImage(named:)방식으로 생성한 이미지 객체는 한번 읽어온 이미지를 메모리에 저장해둔 다음, 두번째 호출부터는 메모리에 저장된 이미지를 가져온다. (단점으로,
객체를 다 사용한 후에도 잘 해제되지 않는다는것) 메모리 점유가 걱정되는 경우에는 UIImage(contentsOfFile:)생성자를 사용해서 이미지 객체를 생성하는 것이 좋다.(캐싱되지 않음)

# 테이블 뷰의 행 높이를 결정하는 방식

코코아 터치 프레임워크에서는 기본적으로 테이블 뷰의 행 높이를 결정하는 두가지 방식을 제공한다. 

* 모두 동일한 높이를 갖는 방식
* 각 셀마다 다른 높이를 갖는 방식(내부 컨텐츠에 따라 동적으로 높이가 늘어나거나 줄어드는 Self-Sizing Cell방식도 있음)

## tableView(_:estimatedHeightForRowAt:)

tableView(_:estimatedHeightForRowAt:) 메소드는 뷰에서 특정 행의 높이를 설정하고 싶을 때 사용하는 메소드. 

테이블 뷰에서 행의 높이를 결정하는 것은 UITableView 객체의 rowHeight 속성이지만 이 속성을 통해 설정한 높이값은 모든 셀에 공통으로 적용됨.(스토리보드의 Row Height 속성과 동일) 한번 tableView(_:estimatedHeightForRowAt:) 메소드가 구현되면 RowHeight 속성은 무시되고 메소드가 반환하는 값으로 높이가 설정된다. 두번째 인자값으로 전달되는 IndexPath 타입의 행 정보를 이용해 셀별로 다른 높이 설정이 가능해짐.

> .reloadData() : 테이블 뷰 갱신. 데이터 소스를 다시 읽어와 목록을 갱신하는 역할.

* Nil-Coalescing Operator(Nil 병합 연산자)
 * 옵셔널 타입이 해제된다
 * 앞쪽에는 옵셔널 값이, 뒤쪽에는 일반값이 위치한다
 * 뒤쪽에 위치한 일반 값의 타입은 앞쪽 옵셔널 값에서 옵셔널을 해제한 타입과 일치해야 한다.

 두개의 물음표로 이루어진 연산자. `만약 A가 nil이 아닐경우 옵셔널을 해제하고 nil일 경우 대신 B값을 사용하라(A ?? B)`. 옵셔널 타입을 해제함과 동시에 대체 값을 제공해주는 역할.
 
* 셀프 사이징 셀
 * estimatedRowHeight 프로퍼티 : 셀 전체의 높이를 결정하기 전에 임시로 사용할 셀의 높이 값을 나타냅니다.
 * UITableViewAutomaticDimension 객체 : 테이블 뷰의 rowHeight속성에 대입되어 높이값이 동적으로 설정될 것을 테이블 뷰에 알려주는 역할.

